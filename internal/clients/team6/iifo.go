package team6

import (
	"math"

	"github.com/SOMAS2020/SOMAS2020/internal/common/baseclient"
	"github.com/SOMAS2020/SOMAS2020/internal/common/shared"
	"gonum.org/v1/gonum/stat/distuv"
)

func (c *client) MakeDisasterPrediction() shared.DisasterPredictionInfo {
	// similar to the baseclient implement: mean prediction
	disastersHistory := c.disastersHistory
	teamsOfferingTo := []shared.ClientID{}

	xMax := c.ServerReadHandle.GetGameState().Geography.XMax
	xMin := c.ServerReadHandle.GetGameState().Geography.XMin
	yMax := c.ServerReadHandle.GetGameState().Geography.YMax
	yMin := c.ServerReadHandle.GetGameState().Geography.YMin

	predictedX := distuv.Uniform{Min: xMin, Max: xMax}.Rand()
	predictedY := distuv.Uniform{Min: yMin, Max: yMax}.Rand()
	predictedLambda := float64(0)

	// we can get these values only if there are set visible
	if c.ServerReadHandle.GetGameConfig().DisasterConfig.DisasterPeriod.Valid {
		disasterPeriod := c.ServerReadHandle.GetGameConfig().DisasterConfig.DisasterPeriod.Value

		if c.ServerReadHandle.GetGameConfig().DisasterConfig.StochasticDisasters.Valid {
			isStochastic := c.ServerReadHandle.GetGameConfig().DisasterConfig.StochasticDisasters.Value

			if isStochastic {

			} else {

			}

		} else {

		}
	} else {
		if c.ServerReadHandle.GetGameConfig().DisasterConfig.StochasticDisasters.Valid {
			isStochastic = c.ServerReadHandle.GetGameConfig().DisasterConfig.StochasticDisasters.Value

		} else {

		}
	}

	prediction := shared.DisasterPrediction{
		CoordinateX: meanDisaster.CoordinateX,
		CoordinateY: meanDisaster.CoordinateY,
		Magnitude:   meanDisaster.Magnitude,
		TimeLeft:    meanDisaster.Turn,
		Confidence:  determineConfidence(pastDisasters, meanDisaster, 100.0),
	}

	c.disasterPredictions[c.GetID()] = prediction

	return shared.DisasterPredictionInfo{
		PredictionMade: prediction,
		TeamsOfferedTo: teamsOfferingTo,
	}
}

func (c *client) ReceiveDisasterPredictions(receivedPredictions shared.ReceivedDisasterPredictionsDict) {
	numberOfPredictions := float64(len(receivedPredictions) + 1)
	ourPrediction := c.disasterPredictions[c.GetID()]
	selfConfidence := ourPrediction.Confidence

	if len(receivedPredictions) == 0 && selfConfidence == 0 {
		defer c.Logf("No prediction can be made")
		return
	}

	// Initialise running totals using our own island's predictions
	totalCoordinateX := selfConfidence * ourPrediction.CoordinateX
	totalCoordinateY := selfConfidence * ourPrediction.CoordinateY
	totalMagnitude := selfConfidence * ourPrediction.Magnitude
	totalTimeLeft := uint(math.Round(selfConfidence)) * ourPrediction.TimeLeft
	totalConfidence := selfConfidence

	// Add other island's predictions using their confidence values
	for team, prediction := range receivedPredictions {
		c.disasterPredictions[team] = prediction.PredictionMade

		totalCoordinateX += c.trustRank[team] * prediction.PredictionMade.Confidence * prediction.PredictionMade.CoordinateX
		totalCoordinateY += c.trustRank[team] * prediction.PredictionMade.Confidence * prediction.PredictionMade.CoordinateY
		totalMagnitude += c.trustRank[team] * prediction.PredictionMade.Confidence * prediction.PredictionMade.Magnitude
		totalTimeLeft += prediction.PredictionMade.TimeLeft * uint(math.Round(c.trustRank[team]*prediction.PredictionMade.Confidence))
		totalConfidence += c.trustRank[team] * prediction.PredictionMade.Confidence
	}

	// Finally get the final prediction generated by considering predictions from all islands that we have available
	// This result is currently unused but would be used in decision making in full implementation
	finalPrediction := shared.DisasterPrediction{
		CoordinateX: totalCoordinateX / numberOfPredictions,
		CoordinateY: totalCoordinateY / numberOfPredictions,
		Magnitude:   totalMagnitude / numberOfPredictions,
		TimeLeft:    uint((float64(totalTimeLeft) / numberOfPredictions) + 0.5),
		Confidence:  totalConfidence / numberOfPredictions,
	}

	c.Logf("Final Prediction: [%v]", finalPrediction)
}

func getMeanDisaster(pastDisastersList baseclient.PastDisastersList) baseclient.DisasterInfo {
	totalCoordinateX, totalCoordinateY, totalMagnitude, totalTurn := 0.0, 0.0, 0.0, 0.0
	numberDisastersPassed := float64(len(pastDisastersList))

	for _, disaster := range pastDisastersList {
		totalCoordinateX += disaster.CoordinateX
		totalCoordinateY += disaster.CoordinateY
		totalMagnitude += float64(disaster.Magnitude)
		totalTurn += float64(disaster.Turn)
	}

	meanDisaster := baseclient.DisasterInfo{
		CoordinateX: totalCoordinateX / numberDisastersPassed,
		CoordinateY: totalCoordinateY / numberDisastersPassed,
		Magnitude:   totalMagnitude / numberDisastersPassed,
		Turn:        uint(math.Round(totalTurn / numberDisastersPassed)),
	}

	return meanDisaster
}

func determineConfidence(pastDisastersList baseclient.PastDisastersList, meanDisaster baseclient.DisasterInfo, varianceLimit float64) float64 {
	totalDisaster := baseclient.DisasterInfo{}
	numberDisastersPassed := float64(len(pastDisastersList))

	// Find the sum of the square of the difference between the actual and mean, for each field
	for _, disaster := range pastDisastersList {
		totalDisaster.CoordinateX += math.Pow(disaster.CoordinateX-meanDisaster.CoordinateX, 2)
		totalDisaster.CoordinateY += math.Pow(disaster.CoordinateY-meanDisaster.CoordinateY, 2)
		totalDisaster.Magnitude += math.Pow(disaster.Magnitude-meanDisaster.Magnitude, 2)
		totalDisaster.Turn += uint(math.Round(math.Pow(float64(disaster.Turn-meanDisaster.Turn), 2)))
	}

	// Find the sum of the variances and the average variance
	varianceSum := (totalDisaster.CoordinateX + totalDisaster.CoordinateY + totalDisaster.Magnitude + float64(totalDisaster.Turn)) / numberDisastersPassed
	averageVariance := varianceSum / 4

	// Implement the variance cap chosen
	if averageVariance > varianceLimit {
		averageVariance = varianceLimit
	}

	// Return the confidence of the prediction
	return math.Round(varianceLimit - averageVariance)
}

func (c *client) MakeForageInfo() shared.ForageShareInfo {
	var shareTo []shared.ClientID // containing agents our agent wish to share informationwith

	for id, status := range c.ServerReadHandle.GetGameState().ClientLifeStatuses {
		if status != shared.Dead {
			shareTo = append(shareTo, id)
		}
	}

	var lastDecision shared.ForageDecision
	var lastForageOut shared.Resources

	for forageType, results := range c.forageHistory {
		for _, result := range results {
			if uint(result.turn) == c.ServerReadHandle.GetGameState().Turn-1 {
				lastForageOut = result.forageReturn
				lastDecision = shared.ForageDecision{
					Type:         forageType,
					Contribution: result.forageIn,
				}
			}
		}
	}

	forageInfo := shared.ForageShareInfo{
		DecisionMade:     lastDecision,
		ResourceObtained: lastForageOut,
		ShareTo:          shareTo,
	}

	return forageInfo
}

func (c *client) ReceiveForageInfo(forageInfo []shared.ForageShareInfo) {
	for _, val := range forageInfo {
		c.forageHistory[val.DecisionMade.Type] =
			append(
				c.forageHistory[val.DecisionMade.Type],
				ForageResults{
					forageIn:     val.DecisionMade.Contribution,
					forageReturn: val.ResourceObtained,
					turn:         c.ServerReadHandle.GetGameState().Turn,
				},
			)
	}
}
