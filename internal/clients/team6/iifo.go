package team6

import (
	"math"

	"github.com/SOMAS2020/SOMAS2020/internal/common/baseclient"
	"github.com/SOMAS2020/SOMAS2020/internal/common/shared"
)

func (c *client) MakeDisasterPrediction() shared.DisasterPredictionInfo {
	// similar to the baseclient implement: mean prediction
	pastDisasters := c.disastersHistory
	teamsOfferingTo := []shared.ClientID{}

	if len(pastDisasters) == 0 {
		return shared.DisasterPredictionInfo{
			PredictionMade: shared.DisasterPrediction{},
			TeamsOfferedTo: nil,
		}
	}

	meanDisaster := getMeanDisaster(pastDisasters)

	for team, friendship := range c.friendship {
		// shares the information with good friends
		if friendship > FriendshipLevel(float64(1/2)*float64(c.clientConfig.maxFriendship)) {
			teamsOfferingTo = append(teamsOfferingTo, team)
		}
	}

	prediction := shared.DisasterPrediction{
		CoordinateX: meanDisaster.CoordinateX,
		CoordinateY: meanDisaster.CoordinateY,
		Magnitude:   meanDisaster.Magnitude,
		TimeLeft:    meanDisaster.Turn,
		Confidence:  determineConfidence(pastDisasters, meanDisaster, 100.0),
	}

	c.disasterPredictions[c.GetID()] = prediction

	return shared.DisasterPredictionInfo{
		PredictionMade: prediction,
		TeamsOfferedTo: teamsOfferingTo,
	}
}

func (c *client) ReceiveDisasterPredictions(receivedPredictions shared.ReceivedDisasterPredictionsDict) {
	numberOfPredictions := float64(len(receivedPredictions) + 1)
	ourPrediction := c.disasterPredictions[c.GetID()]
	selfConfidence := ourPrediction.Confidence

	if len(receivedPredictions) == 0 && selfConfidence == 0 {
		defer c.Logf("No prediction can be made")
		return
	}

	// Initialise running totals using our own island's predictions
	totalCoordinateX := selfConfidence * ourPrediction.CoordinateX
	totalCoordinateY := selfConfidence * ourPrediction.CoordinateY
	totalMagnitude := selfConfidence * ourPrediction.Magnitude
	totalTimeLeft := uint(math.Round(selfConfidence)) * ourPrediction.TimeLeft
	totalConfidence := selfConfidence

	// Add other island's predictions using their confidence values
	for team, prediction := range receivedPredictions {
		c.disasterPredictions[team] = prediction.PredictionMade

		totalCoordinateX += c.trustRank[team] * prediction.PredictionMade.Confidence * prediction.PredictionMade.CoordinateX
		totalCoordinateY += c.trustRank[team] * prediction.PredictionMade.Confidence * prediction.PredictionMade.CoordinateY
		totalMagnitude += c.trustRank[team] * prediction.PredictionMade.Confidence * prediction.PredictionMade.Magnitude
		totalTimeLeft += prediction.PredictionMade.TimeLeft * uint(math.Round(c.trustRank[team]*prediction.PredictionMade.Confidence))
		totalConfidence += c.trustRank[team] * prediction.PredictionMade.Confidence
	}

	// Finally get the final prediction generated by considering predictions from all islands that we have available
	// This result is currently unused but would be used in decision making in full implementation
	finalPrediction := shared.DisasterPrediction{
		CoordinateX: totalCoordinateX / numberOfPredictions,
		CoordinateY: totalCoordinateY / numberOfPredictions,
		Magnitude:   totalMagnitude / numberOfPredictions,
		TimeLeft:    uint((float64(totalTimeLeft) / numberOfPredictions) + 0.5),
		Confidence:  totalConfidence / numberOfPredictions,
	}

	c.Logf("Final Prediction: [%v]", finalPrediction)
}

func getMeanDisaster(pastDisastersList baseclient.PastDisastersList) baseclient.DisasterInfo {
	totalCoordinateX, totalCoordinateY, totalMagnitude, totalTurn := 0.0, 0.0, 0.0, 0.0
	numberDisastersPassed := float64(len(pastDisastersList))

	for _, disaster := range pastDisastersList {
		totalCoordinateX += disaster.CoordinateX
		totalCoordinateY += disaster.CoordinateY
		totalMagnitude += float64(disaster.Magnitude)
		totalTurn += float64(disaster.Turn)
	}

	meanDisaster := baseclient.DisasterInfo{
		CoordinateX: totalCoordinateX / numberDisastersPassed,
		CoordinateY: totalCoordinateY / numberDisastersPassed,
		Magnitude:   totalMagnitude / numberDisastersPassed,
		Turn:        uint(math.Round(totalTurn / numberDisastersPassed)),
	}

	return meanDisaster
}

func determineConfidence(pastDisastersList baseclient.PastDisastersList, meanDisaster baseclient.DisasterInfo, varianceLimit float64) float64 {
	totalDisaster := baseclient.DisasterInfo{}
	numberDisastersPassed := float64(len(pastDisastersList))

	// Find the sum of the square of the difference between the actual and mean, for each field
	for _, disaster := range pastDisastersList {
		totalDisaster.CoordinateX += math.Pow(disaster.CoordinateX-meanDisaster.CoordinateX, 2)
		totalDisaster.CoordinateY += math.Pow(disaster.CoordinateY-meanDisaster.CoordinateY, 2)
		totalDisaster.Magnitude += math.Pow(disaster.Magnitude-meanDisaster.Magnitude, 2)
		totalDisaster.Turn += uint(math.Round(math.Pow(float64(disaster.Turn-meanDisaster.Turn), 2)))
	}

	// Find the sum of the variances and the average variance
	varianceSum := (totalDisaster.CoordinateX + totalDisaster.CoordinateY + totalDisaster.Magnitude + float64(totalDisaster.Turn)) / numberDisastersPassed
	averageVariance := varianceSum / 4

	// Implement the variance cap chosen
	if averageVariance > varianceLimit {
		averageVariance = varianceLimit
	}

	// Return the confidence of the prediction
	return math.Round(varianceLimit - averageVariance)
}

func (c *client) MakeForageInfo() shared.ForageShareInfo {
	var shareTo []shared.ClientID // containing agents our agent wish to share informationwith

	for id, status := range c.ServerReadHandle.GetGameState().ClientLifeStatuses {
		if status != shared.Dead {
			shareTo = append(shareTo, id)
		}
	}

	var lastDecision shared.ForageDecision
	var lastForageOut shared.Resources

	for forageType, results := range c.forageHistory {
		for _, result := range results {
			if uint(result.turn) == c.ServerReadHandle.GetGameState().Turn-1 {
				lastForageOut = result.forageReturn
				lastDecision = shared.ForageDecision{
					Type:         forageType,
					Contribution: result.forageIn,
				}
			}
		}
	}

	forageInfo := shared.ForageShareInfo{
		DecisionMade:     lastDecision,
		ResourceObtained: lastForageOut,
		ShareTo:          shareTo,
	}

	return forageInfo
}

func (c *client) ReceiveForageInfo(forageInfo []shared.ForageShareInfo) {
	for _, val := range forageInfo {
		c.forageHistory[val.DecisionMade.Type] =
			append(
				c.forageHistory[val.DecisionMade.Type],
				ForageResults{
					forageIn:     val.DecisionMade.Contribution,
					forageReturn: val.ResourceObtained,
					turn:         c.ServerReadHandle.GetGameState().Turn,
				},
			)
	}
}
